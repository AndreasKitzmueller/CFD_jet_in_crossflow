# ===========================
# A) Solver duplizieren & erweitern (einmalig)
# ===========================

# 1) Original kopieren in den User-Bereich
#    (legt eine Kopie von icoFoam an, die wir "icoFoamColored" nennen)
mkdir -p $WM_PROJECT_USER_DIR/applications/solvers/incompressible
cp -r /usr/lib/openfoam/openfoam2412/applications/solvers/incompressible/icoFoam \
      $WM_PROJECT_USER_DIR/applications/solvers/incompressible/icoFoamColored
cd $WM_PROJECT_USER_DIR/applications/solvers/incompressible/icoFoamColored

# 2) Make/files setzen (Zielname & Binärpfad)
#    Inhalt der Datei Make/files GENAU so setzen:
#    --------------------------------------------
#    icoFoam.C
#    EXE = $(FOAM_USER_APPBIN)/icoFoamColored
#    --------------------------------------------

# 3) createFields.H erweitern (2 Tracer + Diffusivität)
#    Nach den Standardfeldern (nu, p, U, phi, setRefCell, mesh.setFluxRequired…) einfügen:
#    ---------------------------------------------------------------------------
#    // --- Passive tracer fields for coloring two streams
#    volScalarField cA
#    (
#        IOobject("cA", runTime.timeName(), mesh,
#                 IOobject::READ_IF_PRESENT, IOobject::AUTO_WRITE),
#        mesh, dimensionedScalar("zero", dimless, 0)
#    );
#
#    volScalarField cB
#    (
#        IOobject("cB", runTime.timeName(), mesh,
#                 IOobject::READ_IF_PRESENT, IOobject::AUTO_WRITE),
#        mesh, dimensionedScalar("zero", dimless, 0)
#    );
#
#    // Diffusivität (m^2/s): 0 = nur Advektion; 1e-8..1e-6 für Glättung
#    // Variante A: fester Wert
#    dimensionedScalar D("D", dimensionSet(0,2,-1,0,0,0,0), 0);
#    // Variante B (optional): aus transportProperties lesen
#    // dimensionedScalar D("D", dimViscosity, transportProperties);
#    ---------------------------------------------------------------------------

# 4) icoFoam.C – Tracer-Gleichungen einmal pro Zeitschritt lösen
#    Nach der PISO-Schleife, VOR runTime.write(); einfügen:
#    ---------------------------------------------------------------------------
#    // --- Passive tracer transport (once per time step)
#    {
#        fvScalarMatrix cAEqn( fvm::ddt(cA) + fvm::div(phi, cA) - fvm::laplacian(D, cA) );
#        cAEqn.relax(); cAEqn.solve();
#
#        fvScalarMatrix cBEqn( fvm::ddt(cB) + fvm::div(phi, cB) - fvm::laplacian(D, cB) );
#        cBEqn.relax(); cBEqn.solve();
#    }
#    ---------------------------------------------------------------------------
#
#    (Optional, nützlich zum Prüfen: gleich am Anfang der Zeitschleife eine Log-Zeile)
#    ---------------------------------------------------------------------------
#    Info<< ">>> icoFoamColored: tracer build active <<<" << endl;
#    ---------------------------------------------------------------------------

# 5) Bauen
wclean
wmake

# Prüfen, ob das Binary existiert:
which icoFoamColored
ls -l ~/OpenFOAM/$USER-v2412/platforms/linux64GccDPInt32Opt/bin/icoFoamColored


# ===========================
# B) Case-Dateien (pro Fall)
# ===========================
# Angenommene Patches (aus boundary):
#   inletMain (Strom A), jetInlet (Strom B), outlet,
#   Wände: top, floor, sideWalls, ductWalls
#
# Hinweis: 0/cA und 0/cB sind FELD-Dateien (volScalarField) im Zeitordner 0/.
# fvSchemes/fvSolution/controlDict liegen in system/.
# transportProperties liegt in constant/.

# --------------------------------------------------
# 1) 0/cA
# --------------------------------------------------
# FoamFile{version 2.0; format ascii; class volScalarField; object cA;}
# dimensions      [0 0 0 0 0 0 0];
# internalField   uniform 0;
# boundaryField
# {
#     inletMain   { type fixedValue; value uniform 1; }
#     jetInlet    { type fixedValue; value uniform 0; }
#     outlet      { type zeroGradient; }
#     top         { type zeroGradient; }
#     floor       { type zeroGradient; }
#     sideWalls   { type zeroGradient; }
#     ductWalls   { type zeroGradient; }
# }

# --------------------------------------------------
# 2) 0/cB
# --------------------------------------------------
# FoamFile{version 2.0; format ascii; class volScalarField; object cB;}
# dimensions      [0 0 0 0 0 0 0];
# internalField   uniform 0;
# boundaryField
# {
#     inletMain   { type fixedValue; value uniform 0; }
#     jetInlet    { type fixedValue; value uniform 1; }
#     outlet      { type zeroGradient; }
#     top         { type zeroGradient; }
#     floor       { type zeroGradient; }
#     sideWalls   { type zeroGradient; }
#     ductWalls   { type zeroGradient; }
# }
# (Wenn A/B vertauscht sein sollen: die 1/0 an den Inlets tauschen.)

# --------------------------------------------------
# 3) system/fvSchemes  (laminar, minimal sauber)
# --------------------------------------------------
# FoamFile{version 2.0; format ascii; class dictionary; object fvSchemes;}
# ddtSchemes        { default backward; }
# gradSchemes       { default Gauss linear; }
# divSchemes
# {
#     div(phi,U)      Gauss linearUpwind grad(U);
#     div(phi,cA)     Gauss upwind;
#     div(phi,cB)     Gauss upwind;
# }
# laplacianSchemes
# {
#     default         Gauss linear corrected;
#     laplacian(nu,U) Gauss linear corrected;
#     laplacian(D,cA) Gauss linear corrected;
#     laplacian(D,cB) Gauss linear corrected;
# }
# interpolationSchemes { default linear; }
# snGradSchemes        { default corrected; }

# --------------------------------------------------
# 4) system/fvSolution
# --------------------------------------------------
# FoamFile{format ascii; class dictionary; object fvSolution;}
# solvers
# {
#     p       { solver PCG; preconditioner DIC; tolerance 1e-6; relTol 0.05; }
#     pFinal  { $p; relTol 0; }
#
#     U       { solver smoothSolver; smoother symGaussSeidel; tolerance 1e-5; relTol 0; }
#
#     cA      { solver smoothSolver; smoother symGaussSeidel; tolerance 1e-8; relTol 0.1; }
#     cAFinal { $cA; relTol 0; }
#
#     cB      { solver smoothSolver; smoother symGaussSeidel; tolerance 1e-8; relTol 0.1; }
#     cBFinal { $cB; relTol 0; }
# }
# PISO
# {
#     nCorrectors 2;
#     nNonOrthogonalCorrectors 2;
# }

# --------------------------------------------------
# 5) constant/transportProperties
# --------------------------------------------------
# Variante A (D fest im Solver = 0) → nichts weiter nötig.
# Variante B (D aus Dict lesen) → ergänzen:
# D   [0 2 -1 0 0 0 0]  0;    # oder z.B. 1e-8 für leichte Glättung


